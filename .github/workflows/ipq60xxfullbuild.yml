name: IPQ60XX-Triple-Stage-Build

on:
  workflow_dispatch:
    inputs:
      repo_config:
        description: '选择要构建的仓库 (留空则构建所有)'
        required: false
        default: 'all'
        type: choice
        options:
          - all
          - openwrt
          - immwrt
          - libwrt
  workflow_call:

env:
  TZ: Asia/Shanghai
  OPENWRT_PATH: /mnt/openwrt
  CONFIG_BASE_DIR: configs
  DIY_SCRIPT_DIR: scripts
  CACHE_VERSION: v3
  BUILD_LOG_LEVEL: INFO
  BUILD_LOG_FILE: build.log
  REPORT_FILE: build_report.json
  FILE_DATE: ${{ github.run_number }}-${{ github.sha }}

jobs:
  # ==================== 阶段一：构建基础环境 ====================
  Build-Bases:
    runs-on: ubuntu-22.04
    strategy:
      fail-fast: false
      matrix:
        repo_config: ['openwrt', 'immwrt', 'libwrt']
        include:
          - repo_config: openwrt
            repo_url: https://github.com/openwrt/openwrt.git
            repo_branch: master
          - repo_config: immwrt
            repo_url: https://github.com/immortalwrt/immortalwrt.git
            repo_branch: master
          - repo_config: libwrt
            repo_url: https://github.com/LibreWrt/LibreWrt.git
            repo_branch: master
    
    steps:
    - name: 检出代码
      uses: actions/checkout@v4

    - name: 初始化日志系统
      run: |
        chmod +x scripts/logger.sh
        source scripts/logger.sh "base-${{ matrix.repo_config }}-$(date +%s)"
        step_start "INIT" "初始化基础构建日志 (${{ matrix.repo_config }})"

    - name: 克隆仓库
      run: |
        source scripts/logger.sh
        step_start "CLONE_REPO" "克隆 ${{ matrix.repo_config }} 仓库"
        
        # 创建目录
        sudo mkdir -p ${{ env.OPENWRT_PATH }}
        sudo chown $USER:$USER ${{ env.OPENWRT_PATH }}
        
        # 克隆仓库
        git clone ${{ matrix.repo_url }} ${{ env.OPENWRT_PATH }}
        cd ${{ env.OPENWRT_PATH }}
        git checkout ${{ matrix.repo_branch }}
        
        step_complete "CLONE_REPO" "success"

    - name: 生成变量并检查配置
      id: generate_vars
      run: |
        source scripts/logger.sh
        step_start "GEN_VARS" "生成构建变量并检查配置"
        
        # 设置REPO_SHORT变量
        REPO_SHORT="${{ matrix.repo_config }}"
        echo "REPO_SHORT=$REPO_SHORT" >> $GITHUB_ENV
        
        # 加载软件包检查脚本
        chmod +x scripts/package_checker.sh
        source scripts/package_checker.sh
        
        # 查找配置文件
        CONFIG_BASE=$(find_config_file "base_ipq60xx")
        CONFIG_BRANCH=$(find_config_file "base_${REPO_SHORT}")
        
        # 检查配置文件
        check_luci_packages "$CONFIG_BASE" "基础配置"
        check_luci_packages "$CONFIG_BRANCH" "分支配置"
        
        # 合并配置文件
        log "INFO" "合并基础配置和分支配置..."
        cat "$CONFIG_BASE" "$CONFIG_BRANCH" > .config
        
        # 检查合并后的配置
        check_luci_packages ".config" "合并后配置"
        
        # 保存合并后的软件包列表到文件
        grep -E "^CONFIG_PACKAGE_luci-.+=y" .config | sort > /tmp/merged_luci.txt
        
        # 设置输出变量
        echo "repo_short_${REPO_SHORT}=${REPO_SHORT}" >> $GITHUB_OUTPUT
        
        # 提取设备信息
        DEVICE_INFO=$(cat .config | grep "^CONFIG_TARGET_BOARD=" | awk -F '"' '{print $2}' || echo "未知")
        if [ "$DEVICE_INFO" = "未知" ]; then
            DEVICE_INFO=$(cat .config | grep "^CONFIG_TARGET_ARCH_PACKAGES=" | awk -F '"' '{print $2}' || echo "未知")
        fi
        log "INFO" "设备信息: $DEVICE_INFO"
        step_complete "GEN_VARS" "success"

    - name: 运行defconfig
      run: |
        source scripts/logger.sh
        step_start "DEFCONFIG" "运行defconfig"
        cd ${{ env.OPENWRT_PATH }}
        
        # 加载软件包检查脚本
        source scripts/package_checker.sh
        
        # 运行defconfig
        run_defconfig
        
        step_complete "DEFCONFIG" "success"

    - name: 生成软件包对比报告
      run: |
        source scripts/logger.sh
        step_start "PACKAGE_REPORT" "生成软件包对比报告"
        cd ${{ env.OPENWRT_PATH }}
        
        # 加载软件包检查脚本
        source scripts/package_checker.sh
        
        # 从文件读取之前的软件包列表
        MERGED_LUCI=$(cat /tmp/merged_luci.txt)
        
        # 生成对比报告
        generate_package_report "$MERGED_LUCI" "基础环境"
        
        step_complete "PACKAGE_REPORT" "success"

    - name: 安装依赖
      run: |
        source scripts/logger.sh
        step_start "INSTALL_DEPS" "安装构建依赖"
        cd ${{ env.OPENWRT_PATH }}
        
        # 更新包列表并安装依赖
        sudo apt-get update
        sudo apt-get install -y build-essential clang flex bison g++ gawk \
          gcc-multilib g++-multilib gettext git libncurses5-dev libssl-dev \
          python3-distutils python3-setuptools python3-yaml rsync unzip \
          zlib1g-dev file swig
        
        # 安装OpenWrt特定的依赖
        ./scripts/feeds update -a
        ./scripts/feeds install -a
        
        step_complete "INSTALL_DEPS" "success"

    - name: 构建基础环境
      run: |
        source scripts/logger.sh
        step_start "BUILD_BASE" "构建基础环境"
        cd ${{ env.OPENWRT_PATH }}
        
        # 构建工具链
        if make -j$(nproc) toolchain/install > /dev/null 2>&1; then
          log "INFO" "工具链构建成功"
        else
          log "ERROR" "工具链构建失败"
          exit 1
        fi
        
        step_complete "BUILD_BASE" "success"

    - name: 上传基础环境
      uses: actions/upload-artifact@v4
      with:
        name: base-env-${{ matrix.repo_config }}
        path: ${{ env.OPENWRT_PATH }}
        retention-days: 7

  # ==================== 阶段二：集中预编译通用软件包 ====================
  Prebuild-Packages:
    needs: Build-Bases
    runs-on: ubuntu-22.04
    steps:
    - name: 检出代码
      uses: actions/checkout@v4

    - name: 初始化日志系统
      run: |
        chmod +x scripts/logger.sh
        source scripts/logger.sh "prebuild-$(date +%s)"
        step_start "INIT" "初始化预编译构建日志"

    - name: 创建目录
      run: |
        source scripts/logger.sh
        sudo mkdir -p ${{ env.OPENWRT_PATH }}
        sudo chown $USER:$USER ${{ env.OPENWRT_PATH }}

    - name: 下载基础环境
      uses: actions/download-artifact@v4
      with:
        name: base-env-openwrt
        path: ${{ env.OPENWRT_PATH }}

    - name: 生成"超级配置"并检查
      id: generate_super_config
      run: |
        source scripts/logger.sh
        step_start "GEN_SUPER_CONFIG" "生成包含所有变体软件包的超级配置"
        cd "$OPENWRT_PATH"
        
        # 加载软件包检查脚本
        source scripts/package_checker.sh
        
        # 创建基础配置
        echo "CONFIG_TARGET_ipq60xx=y" > .config
        echo "CONFIG_TARGET_ipq60xx_DEVICE_generic=y" >> .config
        echo "CONFIG_TARGET_DEVICE_ipq60xx_generic=y" >> .config
        
        # 检查基础配置
        check_luci_packages ".config" "基础配置"
        
        # 合并所有变体配置
        for variant in Pro Max Ultra; do
          log "INFO" "合并 $variant 配置"
          if [ -f "${{ env.CONFIG_BASE_DIR }}/${variant}.config" ]; then
            check_luci_packages "${{ env.CONFIG_BASE_DIR }}/${variant}.config" "$variant 配置"
            cat "${{ env.CONFIG_BASE_DIR }}/${variant}.config" >> .config
          else
            log "WARN" "配置文件不存在: ${{ env.CONFIG_BASE_DIR }}/${variant}.config"
          fi
        done
        
        # 检查超级配置
        check_luci_packages ".config" "超级配置合并后"
        
        # 保存合并后的软件包列表到文件
        grep -E "^CONFIG_PACKAGE_luci-.+=y" .config | sort > /tmp/super_luci.txt
        
        log "INFO" "超级配置生成完成"
        step_complete "GEN_SUPER_CONFIG" "success"

    - name: 运行defconfig
      run: |
        source scripts/logger.sh
        step_start "DEFCONFIG" "运行defconfig"
        cd "$OPENWRT_PATH"
        
        # 加载软件包检查脚本
        source scripts/package_checker.sh
        
        # 运行defconfig
        run_defconfig
        
        step_complete "DEFCONFIG" "success"

    - name: 生成软件包对比报告
      run: |
        source scripts/logger.sh
        step_start "PACKAGE_REPORT" "生成软件包对比报告"
        cd "$OPENWRT_PATH"
        
        # 加载软件包检查脚本
        source scripts/package_checker.sh
        
        # 从文件读取之前的软件包列表
        SUPER_LUCI=$(cat /tmp/super_luci.txt)
        
        # 生成对比报告
        generate_package_report "$SUPER_LUCI" "超级配置"
        
        step_complete "PACKAGE_REPORT" "success"

    - name: 缓存预编译软件包
      uses: actions/cache@v4
      with:
        key: ${{ env.CACHE_VERSION }}-prebuilt-packages-ipq60xx-${{ hashFiles('configs/Pro.config', 'configs/Max.config', 'configs/Ultra.config') }}
        path: |
          ${{ env.OPENWRT_PATH }}/staging_dir
          ${{ env.OPENWRT_PATH }}/build_dir
          ${{ env.OPENWRT_PATH }}/dl

    - name: 预编译所有第三方软件包（并行模式）
      id: prebuild_parallel
      continue-on-error: true
      run: |
        source scripts/logger.sh
        step_start "PREBUILD_PKGS_PARALLEL" "预编译所有第三方软件包（并行模式）"
        cd "$OPENWRT_PATH"
        
        BUILD_LOG="$GITHUB_WORKSPACE/prebuild_parallel.log"
        
        PACKAGES=$(grep -E "^CONFIG_PACKAGE_luci-.+=y" .config | sed 's/CONFIG_PACKAGE_//' | sed 's/=y//' | tr '\n' ' ')
        if [ -z "$PACKAGES" ]; then
          log "WARN" "未找到需要预编译的 Luci 软件包，跳过编译。"
          echo "status=success" >> $GITHUB_OUTPUT
          step_complete "PREBUILD_PKGS_PARALLEL" "success"
        else
          log "INFO" "即将预编译的软件包: $PACKAGES"
          if make -j$(nproc) $PACKAGES > "$BUILD_LOG" 2>&1; then
            log "INFO" "并行预编译成功"
            echo "status=success" >> $GITHUB_OUTPUT
            step_complete "PREBUILD_PKGS_PARALLEL" "success"
          else
            log "ERROR" "并行预编译失败，将尝试单线程编译"
            echo "status=failed" >> $GITHUB_OUTPUT
            step_complete "PREBUILD_PKGS_PARALLEL" "failed"
            exit 1
          fi
        fi

    - name: 预编译所有第三方软件包（单线程模式）
      id: prebuild_serial
      if: steps.prebuild_parallel.outcome == 'failure'
      run: |
        source scripts/logger.sh
        step_start "PREBUILD_PKGS_SERIAL" "预编译所有第三方软件包（单线程详细模式）"
        cd "$OPENWRT_PATH"
        
        BUILD_LOG="$GITHUB_WORKSPACE/prebuild_serial.log"
        
        PACKAGES=$(grep -E "^CONFIG_PACKAGE_luci-.+=y" .config | sed 's/CONFIG_PACKAGE_//' | sed 's/=y//' | tr '\n' ' ')
        
        log "INFO" "开始单线程详细预编译软件包: $PACKAGES"
        if make -j1 V=s $PACKAGES > "$BUILD_LOG" 2>&1; then
          log "INFO" "单线程预编译成功"
          echo "status=success" >> $GITHUB_OUTPUT
          step_complete "PREBUILD_PKGS_SERIAL" "success"
        else
          log "ERROR" "单线程预编译也失败了"
          
          log "ERROR" "预编译错误详情（最后20行）："
          tail -20 "$BUILD_LOG" | while read line; do
            log "ERROR" "$line"
          done
          
          echo "status=failed" >> $GITHUB_OUTPUT
          step_complete "PREBUILD_PKGS_SERIAL" "failed"
          exit 1
        fi

    - name: 上传预编译日志
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: prebuild-logs
        path: |
          ${{ github.workspace }}/prebuild_parallel.log
          ${{ github.workspace }}/prebuild_serial.log
        retention-days: 7

    - name: 上传预编译软件包
      if: steps.prebuild_parallel.outcome == 'success' || steps.prebuild_serial.outcome == 'success'
      uses: actions/upload-artifact@v4
      with:
        name: prebuilt-packages-ipq60xx
        path: ${{ env.OPENWRT_PATH }}/staging_dir
        retention-days: 7

  # ==================== 阶段三：并行组装变体固件 ====================
  Assemble-Variants:
    needs: [Build-Bases, Prebuild-Packages]
    if: success() && needs.Prebuild-Packages.result == 'success'
    runs-on: ubuntu-22.04
    strategy:
      fail-fast: false
      matrix:
        repo: ['openwrt', 'immwrt', 'libwrt']
        variant: ['Pro', 'Max', 'Ultra']
    
    steps:
    - name: 检出代码
      uses: actions/checkout@v4

    - name: 初始化日志系统
      run: |
        chmod +x scripts/logger.sh
        source scripts/logger.sh "variant-${{ matrix.repo }}-${{ matrix.variant }}-$(date +%s)"
        step_start "INIT" "初始化变体组装日志 (${{ matrix.repo }}-${{ matrix.variant }})"

    - name: 创建目录
      run: |
        source scripts/logger.sh
        sudo mkdir -p ${{ env.OPENWRT_PATH }}
        sudo chown $USER:$USER ${{ env.OPENWRT_PATH }}

    - name: 下载基础环境
      uses: actions/download-artifact@v4
      with:
        name: base-env-${{ matrix.repo }}
        path: ${{ env.OPENWRT_PATH }}

    - name: 下载预编译软件包
      uses: actions/download-artifact@v4
      with:
        name: prebuilt-packages-ipq60xx
        path: ${{ env.OPENWRT_PATH }}/staging_dir

    - name: 准备变体配置并检查
      run: |
        source scripts/logger.sh
        step_start "PREP_VARIANT" "准备变体配置 (${{ matrix.variant }})"
        cd "$OPENWRT_PATH"
        
        # 加载软件包检查脚本
        source scripts/package_checker.sh
        
        # 查找配置文件
        CONFIG_BASE=$(find_config_file "base_ipq60xx")
        CONFIG_VARIANT=$(find_config_file "${{ matrix.variant }}")
        
        # 检查配置文件
        check_luci_packages "$CONFIG_BASE" "基础配置"
        check_luci_packages "$CONFIG_VARIANT" "${{ matrix.variant }} 配置"
        
        # 合并配置文件
        cat "$CONFIG_BASE" "$CONFIG_VARIANT" > .config.tmp && mv .config.tmp .config
        
        # 检查合并后的配置
        check_luci_packages ".config" "变体合并后配置"
        
        # 保存合并后的软件包列表到文件
        grep -E "^CONFIG_PACKAGE_luci-.+=y" .config | sort > /tmp/variant_luci.txt
        
        step_complete "PREP_VARIANT" "success"

    - name: 运行defconfig
      run: |
        source scripts/logger.sh
        step_start "DEFCONFIG" "运行defconfig"
        cd "$OPENWRT_PATH"
        
        # 加载软件包检查脚本
        source scripts/package_checker.sh
        
        # 运行defconfig
        run_defconfig
        
        step_complete "DEFCONFIG" "success"

    - name: 生成软件包对比报告
      run: |
        source scripts/logger.sh
        step_start "PACKAGE_REPORT" "生成软件包对比报告"
        cd "$OPENWRT_PATH"
        
        # 加载软件包检查脚本
        source scripts/package_checker.sh
        
        # 从文件读取之前的软件包列表
        VARIANT_LUCI=$(cat /tmp/variant_luci.txt)
        
        # 生成对比报告
        generate_package_report "$VARIANT_LUCI" "变体 ${{ matrix.variant }}"
        
        step_complete "PACKAGE_REPORT" "success"

    - name: 组装固件（并行模式）
      id: assemble_parallel
      continue-on-error: true
      run: |
        source scripts/logger.sh
        step_start "ASSEMBLE_FIRMWARE_PARALLEL" "组装最终固件（并行模式）"
        cd "$OPENWRT_PATH"
        
        BUILD_LOG="$GITHUB_WORKSPACE/assemble_parallel.log"
        
        if make -j$(nproc) > "$BUILD_LOG" 2>&1; then
          log "INFO" "并行组装固件成功"
          echo "status=success" >> $GITHUB_OUTPUT
          step_complete "ASSEMBLE_FIRMWARE_PARALLEL" "success"
        else
          log "ERROR" "并行组装固件失败，将尝试单线程组装"
          echo "status=failed" >> $GITHUB_OUTPUT
          step_complete "ASSEMBLE_FIRMWARE_PARALLEL" "failed"
          exit 1
        fi

    - name: 组装固件（单线程模式）
      id: assemble_serial
      if: steps.assemble_parallel.outcome == 'failure'
      run: |
        source scripts/logger.sh
        step_start "ASSEMBLE_FIRMWARE_SERIAL" "组装最终固件（单线程详细模式）"
        cd "$OPENWRT_PATH"
        
        BUILD_LOG="$GITHUB_WORKSPACE/assemble_serial.log"
        
        if make -j1 V=s > "$BUILD_LOG" 2>&1; then
          log "INFO" "单线程组装固件成功"
          echo "status=success" >> $GITHUB_OUTPUT
          step_complete "ASSEMBLE_FIRMWARE_SERIAL" "success"
        else
          log "ERROR" "单线程组装固件也失败了"
          
          log "ERROR" "组装固件错误详情（最后20行）："
          tail -20 "$BUILD_LOG" | while read line; do
            log "ERROR" "$line"
          done
          
          echo "status=failed" >> $GITHUB_OUTPUT
          step_complete "ASSEMBLE_FIRMWARE_SERIAL" "failed"
          exit 1
        fi

    - name: 上传固件产物
      if: steps.assemble_parallel.outcome == 'success' || steps.assemble_serial.outcome == 'success'
      uses: actions/upload-artifact@v4
      with:
        name: firmware-${{ matrix.repo }}-${{ matrix.variant }}-${{ env.FILE_DATE }}
        path: ${{ env.OPENWRT_PATH }}/bin/targets/
        retention-days: 30

    - name: 上传构建日志
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: logs-${{ matrix.repo }}-${{ matrix.variant }}-${{ env.FILE_DATE }}
        path: |
          ${{ github.workspace }}/$BUILD_LOG_FILE
          ${{ github.workspace }}/$REPORT_FILE
          ${{ github.workspace }}/assemble_parallel.log
          ${{ github.workspace }}/assemble_serial.log
        retention-days: 7
