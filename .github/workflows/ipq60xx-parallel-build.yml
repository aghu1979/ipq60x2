name: IPQ60XX-Parallel-Build-Release

on:
  workflow_dispatch:
    inputs:
      repo_config:
        description: '仓库配置'
        required: true
        type: choice
        options:
          - immwrt
          - openwrt
          - libwrt
      chip_family:
        description: '芯片系列'
        required: true
        type: choice
        options:
          - ipq60xx
      source_hash:
        description: '源码哈希'
        required: true
      config_hash:
        description: '配置哈希'
        required: true
      feeds_hash:
        description: 'Feeds哈希'
        required: true
      build_id:
        description: '基础构建ID'
        required: true

env:
  # 基础配置
  TZ: Asia/Shanghai
  OPENWRT_PATH: /mnt/openwrt
  
  # 仓库配置
  CONFIG_BASE_DIR: configs
  DIY_SCRIPT_DIR: scripts
  
  # 缓存配置
  CACHE_VERSION: v1
  
  # 日志配置
  LOG_LEVEL: INFO
  LOG_FILE: parallel_build.log
  REPORT_FILE: parallel_build_report.json

jobs:
  Build:
    runs-on: ubuntu-22.04
    strategy:
      matrix:
        # 定义要并行构建的配置
        config_type: 
          - Pro
          - Max
          - Ultra
        repo_config: 
          - ${{ github.event.inputs.repo_config }}
        chip_family:
          - ${{ github.event.inputs.chip_family }}
    
    env:
      CONFIG_TYPE: ${{ matrix.config_type }}
      REPO_CONFIG: ${{ matrix.repo_config }}
      CHIP_FAMILY: ${{ matrix.chip_family }}
      BUILD_ID: ${{ github.event.inputs.build_id }}-${{ matrix.config_type }}
      SOURCE_HASH: ${{ github.event.inputs.source_hash }}
      CONFIG_HASH: ${{ github.event.inputs.config_hash }}
      FEEDS_HASH: ${{ github.event.inputs.feeds_hash }}
      
    steps:

    - name: 初始化日志系统
      run: |
        # 创建日志框架
        cat > /tmp/logger.sh << 'EOF'
        #!/bin/bash
        
        # 日志级别定义
        declare -A LOG_LEVELS=([DEBUG]=0 [INFO]=1 [WARN]=2 [ERROR]=3)
        CURRENT_LEVEL=${LOG_LEVELS[$LOG_LEVEL]}
        
        # 日志文件
        LOG_FILE="$GITHUB_WORKSPACE/$LOG_FILE"
        REPORT_FILE="$GITHUB_WORKSPACE/$REPORT_FILE"
        
        # 初始化日志文件
        echo "=== Parallel Build Log Started at $(date) ===" > "$LOG_FILE"
        echo '{"build_id":"'$BUILD_ID'","start_time":"'$(date -Iseconds)'","steps":[],"errors":[],"warnings":[],"build_errors":[]}' > "$REPORT_FILE"
        
        # 日志函数
        log() {
            local level="$1"
            local message="$2"
            local step="${3:-$(caller | awk '{print $2}')}"
            local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
            
            # 检查日志级别
            if [ ${LOG_LEVELS[$level]} -ge $CURRENT_LEVEL ]; then
                # 控制台输出（带颜色）
                case $level in
                    DEBUG) echo -e "\033[0;37m[$timestamp] [DEBUG] $message\033[0m" ;;
                    INFO)  echo -e "\033[0;34m[$timestamp] [INFO] $message\033[0m" ;;
                    WARN)  echo -e "\033[0;33m[$timestamp] [WARN] $message\033[0m" ;;
                    ERROR) echo -e "\033[1;41;37m[$timestamp] [ERROR] $message\033[0m" ;;
                esac
                
                # 文件输出
                echo "[$timestamp] [$level] [Step: $step] $message" >> "$LOG_FILE"
            fi
        }
        
        # 导出函数
        export -f log
        EOF
        
        chmod +x /tmp/logger.sh
        echo "LOGGER_SCRIPT=/tmp/logger.sh" >> $GITHUB_ENV
        
        # 初始化日志
        source /tmp/logger.sh
        log "INFO" "并行构建ID: $BUILD_ID"
        log "INFO" "配置类型: $CONFIG_TYPE"
        log "INFO" "仓库配置: $REPO_CONFIG"
        log "INFO" "芯片系列: $CHIP_FAMILY"

    - name: 初始化环境
      run: |
        source "$LOGGER_SCRIPT"
        log "INFO" "更新系统包..."
        sudo -E apt-get -y update
        sudo -E apt-get -y install $(curl -fsSL is.gd/depends_ubuntu_2204)
        
        # 安装GitHub CLI
        log "INFO" "安装GitHub CLI..."
        curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg | sudo dd of=/usr/share/keyrings/githubcli-archive-keyring.gpg
        echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" | sudo tee /etc/apt/sources.list.d/github-cli.list > /dev/null
        sudo apt update
        sudo apt install gh -y
        
        # 配置时区
        sudo timedatectl set-timezone "$TZ"

    - name: 检出代码
      uses: actions/checkout@main

    - name: 读取仓库配置
      run: |
        source "$LOGGER_SCRIPT"
        
        # 检查仓库配置文件
        REPO_CONFIG_FILE="${GITHUB_WORKSPACE}/${CONFIG_BASE_DIR}/repos.json"
        REPO_INFO=$(jq -r --arg repo "$REPO_CONFIG" '.[$repo]' "$REPO_CONFIG_FILE")
        
        REPO_URL=$(echo "$REPO_INFO" | jq -r '.url')
        REPO_BRANCH=$(echo "$REPO_INFO" | jq -r '.branch')
        REPO_SHORT=$(echo "$REPO_INFO" | jq -r '.short')
        
        echo "REPO_URL=$REPO_URL" >> $GITHUB_ENV
        echo "REPO_BRANCH=$REPO_BRANCH" >> $GITHUB_ENV
        echo "REPO_SHORT=$REPO_SHORT" >> $GITHUB_ENV
        
        SOURCE_REPO="$(echo "$REPO_URL" | awk -F '/' '{print $(NF)}')"
        echo "SOURCE_REPO=$SOURCE_REPO" >> $GITHUB_ENV
        
        log "INFO" "仓库: $REPO_URL"
        log "INFO" "分支: $REPO_BRANCH"

    - name: 克隆源代码
      run: |
        source "$LOGGER_SCRIPT"
        
        log "INFO" "创建工作目录: $OPENWRT_PATH"
        sudo mkdir -p "$OPENWRT_PATH"
        sudo chown -R $(id -u):$(id -g) "$OPENWRT_PATH"
        
        log "INFO" "克隆源代码..."
        git clone --depth 1 -b "$REPO_BRANCH" --single-branch "$REPO_URL" "$OPENWRT_PATH"

    - name: 下载基础环境缓存
      run: |
        source "$LOGGER_SCRIPT"
        
        # 下载基础环境artifact
        log "INFO" "下载基础环境缓存..."
        BASE_ARTIFACT="${SOURCE_REPO}-base-${CHIP_FAMILY}-${REPO_SHORT}-$(date +%Y.%m.%d)"
        
        # 获取最新的artifact
        ARTIFACT_URL=$(gh api repos/${{ github.repository }}/actions/artifacts \
          --jq '.artifacts[] | select(.name == "'$BASE_ARTIFACT'") | .archive_download_url' | head -1)
        
        if [ -n "$ARTIFACT_URL" ]; then
          log "INFO" "找到基础环境artifact: $BASE_ARTIFACT"
          curl -L -o base_env.zip "$ARTIFACT_URL"
          unzip -q base_env.zip -d "$OPENWRT_PATH"
          rm base_env.zip
          log "INFO" "基础环境缓存下载成功"
        else
          log "ERROR" "未找到基础环境artifact"
          exit 1
        fi

    - name: 恢复缓存
      uses: actions/cache@main
      with:
        key: ${{ env.CACHE_VERSION }}-${{ env.SOURCE_REPO }}-${{ env.REPO_BRANCH }}-${{ env.CHIP_FAMILY }}-${{ env.SOURCE_HASH }}-${{ env.CONFIG_HASH }}
        path: |
          ${{ env.OPENWRT_PATH }}/.ccache
          ${{ env.OPENWRT_PATH }}/staging_dir

    - name: 恢复Feeds缓存
      uses: actions/cache@main
      with:
        key: ${{ env.CACHE_VERSION }}-feeds-${{ env.SOURCE_REPO }}-${{ env.REPO_BRANCH }}-${{ env.SOURCE_HASH }}-${{ env.FEEDS_HASH }}
        path: |
          ${{ env.OPENWRT_PATH }}/feeds
          ${{ env.OPENWRT_PATH }}/dl
          ${{ env.OPENWRT_PATH }}/package/feeds

    - name: 恢复DL缓存
      uses: actions/cache@main
      with:
        key: ${{ env.CACHE_VERSION }}-dl-${{ env.SOURCE_REPO }}-${{ env.REPO_BRANCH }}-${{ env.SOURCE_HASH }}
        path: |
          ${{ env.OPENWRT_PATH }}/dl

    - name: 加载配置文件
      run: |
        source "$LOGGER_SCRIPT"
        
        cd "$OPENWRT_PATH"
        
        # 查找配置文件
        CONFIG_FILE="${GITHUB_WORKSPACE}/${CONFIG_BASE_DIR}/${CONFIG_TYPE}.config"
        if [ ! -f "$CONFIG_FILE" ]; then
          log "ERROR" "配置文件不存在: $CONFIG_FILE"
          exit 1
        fi
        
        log "INFO" "使用配置文件: $CONFIG_FILE"
        
        # 复制配置文件
        cp "$CONFIG_FILE" "$OPENWRT_PATH/.config"
        
        # 运行defconfig
        make defconfig
        
        # 提取设备信息
        DEVICE_TARGET=$(cat .config | grep CONFIG_TARGET_BOARD | awk -F '"' '{print $2}')
        DEVICE_SUBTARGET=$(cat .config | grep CONFIG_TARGET_SUBTARGET | awk -F '"' '{print $2}')
        DEVICE_NAMES=$(grep -oP "CONFIG_TARGET_DEVICE_.*_${CHIP_FAMILY}_DEVICE_\K[^=]+" "$CONFIG_FILE" | tr '\n' ' ')
        
        echo "DEVICE_TARGET=$DEVICE_TARGET" >> $GITHUB_ENV
        echo "DEVICE_SUBTARGET=$DEVICE_SUBTARGET" >> $GITHUB_ENV
        echo "DEVICE_NAMES=$DEVICE_NAMES" >> $GITHUB_ENV
        
        log "INFO" "设备目标: $DEVICE_TARGET"
        log "INFO" "设备子目标: $DEVICE_SUBTARGET"
        log "INFO" "设备名称: $DEVICE_NAMES"

    - name: 编译固件
      run: |
        source "$LOGGER_SCRIPT"
        
        cd "$OPENWRT_PATH"
        log "INFO" "开始编译固件..."
        log "INFO" "使用 $(nproc) 个线程编译"
        
        # 创建错误监控脚本
        cat > /tmp/monitor_errors.sh << 'EOF'
        #!/bin/bash
        LOG_FILE="$1"
        ERROR_PATTERNS=(
            "failed to build"
            "failed to install"
            "Error:"
            "ERROR:"
            "error:"
            "make.*\*\*\*.*Error"
            "command terminated with signal"
            "cannot stat"
            "No such file or directory"
            "Permission denied"
            "Segmentation fault"
            "Compilation failed"
            "Build failed"
            "undefined reference"
            "multiple definition"
        )
        
        tail -f "$LOG_FILE" | while read line; do
            for pattern in "${ERROR_PATTERNS[@]}"; do
                if echo "$line" | grep -q "$pattern"; then
                    echo "::error ::编译错误: $line"
                    break
                fi
            done
        done
        EOF
        chmod +x /tmp/monitor_errors.sh
        
        # 启动错误监控
        /tmp/monitor_errors.sh /tmp/parallel_build.log &
        MONITOR_PID=$!
        
        # 编译
        if make -j$(nproc) 2>&1 | tee /tmp/parallel_build.log; then
            log "INFO" "编译成功"
        else
            kill $MONITOR_PID 2>/dev/null || true
            log "ERROR" "编译失败，尝试单线程编译"
            
            # 单线程编译
            /tmp/monitor_errors.sh /tmp/parallel_build.log &
            MONITOR_PID=$!
            
            if make -j1 V=s 2>&1 | tee /tmp/parallel_build.log; then
                log "INFO" "单线程编译成功"
            else
                kill $MONITOR_PID 2>/dev/null || true
                log "ERROR" "编译彻底失败"
                exit 1
            fi
        fi
        
        kill $MONITOR_PID 2>/dev/null || true
        
        # 设置输出
        echo "status=success" >> $GITHUB_OUTPUT
        echo "FILE_DATE=$(date +"%Y.%m.%d")" >> $GITHUB_ENV

    - name: 整理固件文件
      if: steps.compile.outputs.status == 'success'
      run: |
        source "$LOGGER_SCRIPT"
        
        cd "$OPENWRT_PATH"
        
        # 创建输出目录
        OUTPUT_DIR="$GITHUB_WORKSPACE/firmware_${CONFIG_TYPE}_${REPO_SHORT}"
        mkdir -p "$OUTPUT_DIR"
        
        # 复制固件文件
        log "INFO" "整理固件文件..."
        find bin/targets -name "*.bin" -o -name "*.img" | while read file; do
          cp "$file" "$OUTPUT_DIR/"
          log "INFO" "复制: $file"
        done
        
        # 复制manifest
        if [ -f "bin/targets/${DEVICE_TARGET}/${DEVICE_SUBTARGET}/manifest" ]; then
          cp "bin/targets/${DEVICE_TARGET}/${DEVICE_SUBTARGET}/manifest" "$OUTPUT_DIR/"
        fi
        
        # 生成版本信息
        {
          echo "=== 固件信息 ==="
          echo "构建时间: $(date)"
          echo "仓库: $REPO_URL"
          echo "分支: $REPO_BRANCH"
          echo "配置: $CONFIG_TYPE"
          echo "芯片: $CHIP_FAMILY"
          echo "设备: $DEVICE_NAMES"
          echo "源码哈希: $SOURCE_HASH"
          echo ""
          echo "=== 文件列表 ==="
          ls -la "$OUTPUT_DIR/"
        } > "$OUTPUT_DIR/info.txt"
        
        log "INFO" "固件文件整理完成"

    - name: 上传固件
      if: steps.compile.outputs.status == 'success'
      uses: actions/upload-artifact@main
      with:
        name: firmware-${{ env.CONFIG_TYPE }}-${{ env.REPO_SHORT }}-${{ env.FILE_DATE }}
        path: ${{ github.workspace }}/firmware_${{ env.CONFIG_TYPE }}_${{ env.REPO_SHORT }}
        retention-days: 30

  Release:
    needs: Build
    runs-on: ubuntu-22.04
    if: success()
    
    steps:
    - name: 初始化环境
      run: |
        # 安装GitHub CLI
        curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg | sudo dd of=/usr/share/keyrings/githubcli-archive-keyring.gpg
        echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" | sudo tee /etc/apt/sources.list.d/github-cli.list > /dev/null
        sudo apt update
        sudo apt install gh -y

    - name: 检出代码
      uses: actions/checkout@main

    - name: 下载所有固件
      run: |
        # 创建下载目录
        mkdir -p all_firmware
        
        # 下载所有固件artifact
        for config in Pro Max Ultra; do
          for repo in immwrt openwrt libwrt; do
            ARTIFACT_NAME="firmware-${config}-${repo}-$(date +%Y.%m.%d)"
            echo "下载: $ARTIFACT_NAME"
            
            # 获取artifact URL
            ARTIFACT_URL=$(gh api repos/${{ github.repository }}/actions/artifacts \
              --jq '.artifacts[] | select(.name == "'$ARTIFACT_NAME'") | .archive_download_url' | head -1)
            
            if [ -n "$ARTIFACT_URL" ]; then
              # 下载并解压
              mkdir -p "all_firmware/${config}_${repo}"
              curl -L -o "${config}_${repo}.zip" "$ARTIFACT_URL"
              unzip -q "${config}_${repo}.zip" -d "all_firmware/${config}_${repo}"
              rm "${config}_${repo}.zip"
            fi
          done
        done

    - name: 创建Release
      run: |
        # 生成版本号
        VERSION="v$(date +%Y.%m.%d)-${{ github.event.inputs.repo_config }}-${{ github.event.inputs.chip_family }}"
        
        # 生成Release说明
        cat > release_notes.md << EOF
        # OpenWrt 固件发布
        
        ## 基本信息
        - **版本**: $VERSION
        - **构建时间**: $(date)
        - **仓库**: ${{ github.event.inputs.repo_config }}
        - **芯片**: ${{ github.event.inputs.chip_family }}
        - **源码哈希**: ${{ github.event.inputs.source_hash }}
        
        ## 配置说明
        - **Pro**: 基础版本，包含常用功能
        - **Max**: 增强版本，包含更多插件
        - **Ultra**: 完整版本，包含所有功能
        
        ## 文件说明
        每个配置目录包含：
        - 固件文件 (.bin/.img)
        - manifest (软件包列表)
        - info.txt (构建信息)
        
        ## 下载说明
        请根据您的设备型号选择对应的固件文件。
        
        ---
        自动构建于 $(date)
        EOF
        
        # 创建Release
        gh release create "$VERSION" \
          --title "OpenWrt $VERSION" \
          --notes-file release_notes.md \
          --latest \
          all_firmware/*/* || true

    - name: 完成发布
      run: |
        echo "::notice::固件发布完成！版本: v$(date +%Y.%m.%d)-${{ github.event.inputs.repo_config }}-${{ github.event.inputs.chip_family }}"
