name: IPQ60XX-Base-Build

on:
  workflow_dispatch:
  workflow_call:

env:
  # 基础配置
  TZ: Asia/Shanghai
  OPENWRT_PATH: /mnt/openwrt
  
  # 仓库配置 - 使用变量以便扩展
  CONFIG_BASE_DIR: configs
  DIY_SCRIPT_DIR: scripts
  
  # 构建配置
  UPLOAD_BIN_DIR: false
  FIRMWARE_RELEASE: false  # 根据要求，不需要发布release
  
  # 缓存配置 - 移除日期，提高缓存命中率
  CACHE_VERSION: v1
  
  # 日志配置
  LOG_LEVEL: INFO  # DEBUG, INFO, WARN, ERROR
  LOG_FILE: build.log
  REPORT_FILE: build_report.json

jobs:
  Build:
    runs-on: ubuntu-22.04
    strategy:
      matrix:
        # 定义要并行构建的仓库配置
        repo_config: 
          - immwrt
          - openwrt
          - libwrt
        # 芯片系列 - 暂时注释掉ipq80xx，只保留ipq60xx
        chip_family:
          - ipq60xx
          # - ipq80xx  # 暂时注释，还没有扩展计划
    
    # 使用环境变量设置芯片系列和仓库配置
    env:
      CHIP_FAMILY: ${{ matrix.chip_family }}
      REPO_CONFIG: ${{ matrix.repo_config }}
      BUILD_ID: ${{ github.run_id }}-${{ matrix.repo_config }}-${{ matrix.chip_family }}
      
    steps:

    - name: 初始化企业级日志系统
      id: init_logging
      run: |
        # 创建企业级日志框架
        cat > /tmp/logger.sh << 'EOF'
        #!/bin/bash
        
        # 日志级别定义
        declare -A LOG_LEVELS=([DEBUG]=0 [INFO]=1 [WARN]=2 [ERROR]=3)
        CURRENT_LEVEL=${LOG_LEVELS[$LOG_LEVEL]}
        
        # 日志文件
        LOG_FILE="$GITHUB_WORKSPACE/$LOG_FILE"
        REPORT_FILE="$GITHUB_WORKSPACE/$REPORT_FILE"
        
        # 初始化日志文件
        echo "=== Build Log Started at $(date) ===" > "$LOG_FILE"
        echo '{"build_id":"'$BUILD_ID'","start_time":"'$(date -Iseconds)'","steps":[],"errors":[],"warnings":[],"build_errors":[]}' > "$REPORT_FILE"
        
        # 日志函数
        log() {
            local level="$1"
            local message="$2"
            local step="${3:-$(caller | awk '{print $2}')}"
            local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
            
            # 检查日志级别
            if [ ${LOG_LEVELS[$level]} -ge $CURRENT_LEVEL ]; then
                # 控制台输出（带颜色）
                case $level in
                    DEBUG) echo -e "\033[0;37m[$timestamp] [DEBUG] $message\033[0m" ;;
                    INFO)  echo -e "\033[0;34m[$timestamp] [INFO] $message\033[0m" ;;
                    WARN)  echo -e "\033[0;33m[$timestamp] [WARN] $message\033[0m" ;;
                    ERROR) echo -e "\033[1;41;37m[$timestamp] [ERROR] $message\033[0m" ;;
                esac
                
                # 文件输出
                echo "[$timestamp] [$level] [Step: $step] $message" >> "$LOG_FILE"
                
                # 更新报告文件
                if [ "$level" = "ERROR" ]; then
                    jq --arg step "$step" --arg message "$message" --arg time "$timestamp" \
                        '.errors += [{"step":$step,"message":$message,"time":$time}]' "$REPORT_FILE" > "$REPORT_FILE.tmp" && \
                        mv "$REPORT_FILE.tmp" "$REPORT_FILE"
                elif [ "$level" = "WARN" ]; then
                    jq --arg step "$step" --arg message "$message" --arg time "$timestamp" \
                        '.warnings += [{"step":$step,"message":$message,"time":$time}]' "$REPORT_FILE" > "$REPORT_FILE.tmp" && \
                        mv "$REPORT_FILE.tmp" "$REPORT_FILE"
                fi
            fi
        }
        
        # 构建错误记录函数
        log_build_error() {
            local error_msg="$1"
            local package="$2"
            local timestamp=$(date -Iseconds)
            
            # 高亮显示构建错误
            echo -e "\n\033[1;41;37m🔥 构建错误 🔥\033[0m"
            echo -e "\033[1;31m错误信息: $error_msg\033[0m"
            echo -e "\033[1;31m相关包: $package\033[0m"
            echo -e "\033[1;41;37m================\033[0m\n"
            
            # 记录到日志
            log "ERROR" "构建失败: $error_msg (包: $package)"
            
            # 更新报告文件
            jq --arg msg "$error_msg" --arg pkg "$package" --arg time "$timestamp" \
                '.build_errors += [{"message":$msg,"package":$pkg,"time":$time}]' "$REPORT_FILE" > "$REPORT_FILE.tmp" && \
                mv "$REPORT_FILE.tmp" "$REPORT_FILE"
            
            # 发送GitHub通知
            echo "::error ::构建失败: $error_msg (包: $package)"
        }
        
        # 步骤开始
        step_start() {
            local step_name="$1"
            local description="$2"
            local timestamp=$(date -Iseconds)
            
            log "INFO" "▶ 开始执行: $description" "$step_name"
            
            # 更新报告文件
            jq --arg step "$step_name" --arg desc "$description" --arg time "$timestamp" \
                '.steps += [{"name":$step,"description":$desc,"status":"running","start_time":$time}]' "$REPORT_FILE" > "$REPORT_FILE.tmp" && \
                mv "$REPORT_FILE.tmp" "$REPORT_FILE"
        }
        
        # 步骤完成
        step_complete() {
            local step_name="$1"
            local status="$2"  # success, failed, warning
            local timestamp=$(date -Iseconds)
            
            if [ "$status" = "success" ]; then
                log "INFO" "✅ 步骤完成: $step_name" "$step_name"
            elif [ "$status" = "failed" ]; then
                log "ERROR" "❌ 步骤失败: $step_name" "$step_name"
            elif [ "$status" = "warning" ]; then
                log "WARN" "⚠️ 步骤完成（有警告）: $step_name" "$step_name"
            fi
            
            # 更新报告文件
            jq --arg step "$step_name" --arg status "$status" --arg time "$timestamp" \
                '(.steps[] | select(.name == $step)) |= . + {"status":$status,"end_time":$time}' "$REPORT_FILE" > "$REPORT_FILE.tmp" && \
                mv "$REPORT_FILE.tmp" "$REPORT_FILE"
        }
        
        # 进度显示
        show_progress() {
            local current="$1"
            local total="$2"
            local description="$3"
            local percent=$((current * 100 / total))
            local filled=$((percent / 2))
            local empty=$((50 - filled))
            
            printf "\r\033[0;36m[%3d%%] [" "$percent"
            printf "%*s" $filled | tr ' ' '█'
            printf "%*s" $empty | tr ' ' '░'
            printf "] %s\033[0m" "$description"
        }
        
        # 导出函数
        export -f log log_build_error step_start step_complete show_progress
        EOF
        
        chmod +x /tmp/logger.sh
        echo "LOGGER_SCRIPT=/tmp/logger.sh" >> $GITHUB_ENV
        
        # 初始化日志
        source /tmp/logger.sh
        step_start "INIT" "初始化企业级日志系统"
        log "INFO" "构建ID: $BUILD_ID"
        log "INFO" "日志级别: $LOG_LEVEL"
        log "INFO" "工作目录: $GITHUB_WORKSPACE"
        step_complete "INIT" "success"

    - name: 初始化环境
      id: init_env
      run: |
        source "$LOGGER_SCRIPT"
        step_start "ENV_INIT" "初始化构建环境"
        
        # 设置错误处理
        set -euo pipefail
        trap 'log "ERROR" "命令执行失败: $BASH_COMMAND ($LINENO)"' ERR
        
        log "INFO" "更新系统包..."
        if sudo -E apt-get -y update; then
            log "INFO" "系统包更新成功"
        else
            log "ERROR" "系统包更新失败"
            exit 1
        fi
        
        log "INFO" "安装依赖..."
        if sudo -E apt-get -y install $(curl -fsSL is.gd/depends_ubuntu_2204); then
            log "INFO" "依赖安装成功"
        else
            log "ERROR" "依赖安装失败"
            exit 1
        fi
        
        log "INFO" "配置时区..."
        sudo -E systemctl daemon-reload || log "WARN" "重载系统服务失败"
        if sudo timedatectl set-timezone "$TZ"; then
            log "INFO" "时区设置成功: $TZ"
        else
            log "WARN" "时区设置失败"
        fi
        
        # 显示系统信息
        log "INFO" "=== 系统信息 ==="
        log "INFO" "CPU核心数: $(nproc)"
        log "INFO" "内存总量: $(free -h | grep '^Mem:' | awk '{print $2}')"
        log "INFO" "磁盘空间: $(df -h $GITHUB_WORKSPACE | tail -1 | awk '{print $4}')"
        
        step_complete "ENV_INIT" "success"

    - name: 检出代码
      uses: actions/checkout@main

    - name: 读取仓库配置
      id: read_repo_config
      run: |
        source "$LOGGER_SCRIPT"
        step_start "READ_CONFIG" "读取仓库配置"
        
        cd "$GITHUB_WORKSPACE"
        
        # 检查仓库配置文件
        REPO_CONFIG_FILE="${GITHUB_WORKSPACE}/${CONFIG_BASE_DIR}/repos.json"
        if [ ! -f "$REPO_CONFIG_FILE" ]; then
            log "ERROR" "仓库配置文件不存在: $REPO_CONFIG_FILE"
            exit 1
        fi
        
        log "INFO" "读取仓库配置: $REPO_CONFIG"
        REPO_INFO=$(jq -r --arg repo "$REPO_CONFIG" '.[$repo]' "$REPO_CONFIG_FILE")
        
        if [ "$REPO_INFO" = "null" ]; then
            log "ERROR" "未找到仓库配置: $REPO_CONFIG"
            exit 1
        fi
        
        REPO_URL=$(echo "$REPO_INFO" | jq -r '.url')
        REPO_BRANCH=$(echo "$REPO_INFO" | jq -r '.branch')
        REPO_SHORT=$(echo "$REPO_INFO" | jq -r '.short')
        
        echo "REPO_URL=$REPO_URL" >> $GITHUB_ENV
        echo "REPO_BRANCH=$REPO_BRANCH" >> $GITHUB_ENV
        echo "REPO_SHORT=$REPO_SHORT" >> $GITHUB_ENV
        
        log "INFO" "仓库URL: $REPO_URL"
        log "INFO" "分支: $REPO_BRANCH"
        log "INFO" "简称: $REPO_SHORT"
        
        step_complete "READ_CONFIG" "success"

    - name: 克隆源代码
      id: clone_source
      run: |
        source "$LOGGER_SCRIPT"
        step_start "CLONE_SOURCE" "克隆源代码"
        
        log "INFO" "检查磁盘空间..."
        df -hT "$GITHUB_WORKSPACE"
        
        log "INFO" "创建工作目录: $OPENWRT_PATH"
        if ! sudo mkdir -p "$OPENWRT_PATH"; then
            log "ERROR" "创建工作目录失败"
            exit 1
        fi
        
        if ! sudo chown -R $(id -u):$(id -g) "$OPENWRT_PATH"; then
            log "ERROR" "设置工作目录权限失败"
            exit 1
        fi
        
        log "INFO" "开始克隆源代码..."
        if git clone --depth 1 -b "$REPO_BRANCH" --single-branch "$REPO_URL" "$OPENWRT_PATH"; then
            log "INFO" "源代码克隆成功"
        else
            log "ERROR" "源代码克隆失败"
            exit 1
        fi
        
        cd "$OPENWRT_PATH"
        
        # 获取版本信息
        VERSION_INFO=$(git show -s --date=short --format="作者: %an<br/>时间: %cd<br/>内容: %s<br/>hash: %H")
        echo "VERSION_INFO=$VERSION_INFO" >> $GITHUB_ENV
        
        VERSION_KERNEL=$(grep -oP 'LINUX_KERNEL_HASH-\K[0-9]+\.[0-9]+\.[0-9]+' target/linux/generic/kernel-6.12 2>/dev/null || echo "未知")
        echo "VERSION_KERNEL=$VERSION_KERNEL" >> $GITHUB_ENV
        
        SOURCE_HASH=$(git rev-parse HEAD)
        echo "SOURCE_HASH=$SOURCE_HASH" >> $GITHUB_ENV
        
        log "INFO" "源码哈希: $SOURCE_HASH"
        log "INFO" "内核版本: $VERSION_KERNEL"
        
        step_complete "CLONE_SOURCE" "success"

    - name: 生成变量
      id: generate_vars
      run: |
        source "$LOGGER_SCRIPT"
        step_start "GEN_VARS" "生成构建变量"
        
        cd "$GITHUB_WORKSPACE"
        
        # 查找配置文件函数
        find_config_file() {
            local base_name="$1"
            local config_dir="${GITHUB_WORKSPACE}/${CONFIG_BASE_DIR}"
            
            # 尝试不同格式
            for ext in ".config" ".config.txt"; do
                if [ -f "${config_dir}/${base_name}${ext}" ]; then
                    echo "${config_dir}/${base_name}${ext}"
                    return 0
                fi
            done
            
            # 使用find查找
            local found_file=$(find "$config_dir" -iname "${base_name}.config*" -type f | head -n 1)
            if [ -n "$found_file" ]; then
                echo "$found_file"
                return 0
            fi
            
            return 1
        }
        
        # 查找配置文件
        log "INFO" "查找基础配置文件..."
        CONFIG_BASE=$(find_config_file "base_${CHIP_FAMILY}")
        if [ $? -ne 0 ]; then
            log "ERROR" "基础配置文件不存在: base_${CHIP_FAMILY}"
            exit 1
        fi
        
        log "INFO" "查找分支配置文件..."
        CONFIG_BRANCH=$(find_config_file "base_${REPO_SHORT}")
        if [ $? -ne 0 ]; then
            log "ERROR" "分支配置文件不存在: base_${REPO_SHORT}"
            exit 1
        fi
        
        # 设置脚本路径
        DIY_SCRIPT="${GITHUB_WORKSPACE}/${DIY_SCRIPT_DIR}/diy.sh"
        REPO_SCRIPT="${GITHUB_WORKSPACE}/${DIY_SCRIPT_DIR}/repo.sh"
        
        log "INFO" "基础配置文件: $CONFIG_BASE"
        log "INFO" "分支配置文件: $CONFIG_BRANCH"
        log "INFO" "自定义脚本: $DIY_SCRIPT"
        log "INFO" "软件源脚本: $REPO_SCRIPT"
        
        echo "CONFIG_BASE=$CONFIG_BASE" >> $GITHUB_ENV
        echo "CONFIG_BRANCH=$CONFIG_BRANCH" >> $GITHUB_ENV
        echo "DIY_SCRIPT=$DIY_SCRIPT" >> $GITHUB_ENV
        echo "REPO_SCRIPT=$REPO_SCRIPT" >> $GITHUB_ENV
        
        # 提取设备信息
        log "INFO" "提取设备信息..."
        cp "$CONFIG_BASE" "$OPENWRT_PATH/.config" || {
            log "ERROR" "复制配置文件失败"
            exit 1
        }
        
        cd "$OPENWRT_PATH"
        if ! make defconfig > /dev/null 2>&1; then
            log "ERROR" "运行defconfig失败"
            exit 1
        fi
        
        SOURCE_REPO="$(echo "$REPO_URL" | awk -F '/' '{print $(NF)}')"
        DEVICE_TARGET=$(cat .config | grep CONFIG_TARGET_BOARD | awk -F '"' '{print $2}')
        DEVICE_SUBTARGET=$(cat .config | grep CONFIG_TARGET_SUBTARGET | awk -F '"' '{print $2}')
        DEVICE_NAMES=$(grep -oP "CONFIG_TARGET_DEVICE_.*_${CHIP_FAMILY}_DEVICE_\K[^=]+" "$CONFIG_BASE" | tr '\n' ' ')
        
        echo "SOURCE_REPO=$SOURCE_REPO" >> $GITHUB_ENV
        echo "DEVICE_TARGET=$DEVICE_TARGET" >> $GITHUB_ENV
        echo "DEVICE_SUBTARGET=$DEVICE_SUBTARGET" >> $GITHUB_ENV
        echo "DEVICE_NAMES=$DEVICE_NAMES" >> $GITHUB_ENV
        
        # 生成哈希值
        CONFIG_HASH=$(cat "$CONFIG_BASE" "$CONFIG_BRANCH" | sha256sum | cut -d' ' -f1)
        FEEDS_HASH=$(cat "$OPENWRT_PATH/feeds.conf.default" 2>/dev/null | sha256sum | cut -d' ' -f1 || echo "default")
        
        echo "CONFIG_HASH=$CONFIG_HASH" >> $GITHUB_ENV
        echo "FEEDS_HASH=$FEEDS_HASH" >> $GITHUB_ENV
        
        log "INFO" "设备目标: $DEVICE_TARGET"
        log "INFO" "设备子目标: $DEVICE_SUBTARGET"
        log "INFO" "设备名称: $DEVICE_NAMES"
        
        step_complete "GEN_VARS" "success"

    - name: 缓存工具链
      id: cache_toolchain
      uses: actions/cache@main
      with:
        key: ${{ env.CACHE_VERSION }}-${{ env.SOURCE_REPO }}-${{ env.REPO_BRANCH }}-${{ env.DEVICE_TARGET }}-${{ env.DEVICE_SUBTARGET }}-${{ env.SOURCE_HASH }}-${{ env.CONFIG_HASH }}
        restore-keys: |
          ${{ env.CACHE_VERSION }}-${{ env.SOURCE_REPO }}-${{ env.REPO_BRANCH }}-${{ env.DEVICE_TARGET }}-${{ env.DEVICE_SUBTARGET }}-
          ${{ env.CACHE_VERSION }}-${{ env.SOURCE_REPO }}-${{ env.REPO_BRANCH }}-${{ env.DEVICE_TARGET }}-
          ${{ env.CACHE_VERSION }}-${{ env.SOURCE_REPO }}-${{ env.REPO_BRANCH }}-
        path: |
          ${{ env.OPENWRT_PATH }}/.ccache
          ${{ env.OPENWRT_PATH }}/staging_dir

    - name: 缓存Feeds
      id: cache_feeds
      uses: actions/cache@main
      with:
        key: ${{ env.CACHE_VERSION }}-feeds-${{ env.SOURCE_REPO }}-${{ env.REPO_BRANCH }}-${{ env.SOURCE_HASH }}-${{ env.FEEDS_HASH }}
        restore-keys: |
          ${{ env.CACHE_VERSION }}-feeds-${{ env.SOURCE_REPO }}-${{ env.REPO_BRANCH }}-
          ${{ env.CACHE_VERSION }}-feeds-${{ env.SOURCE_REPO }}-
        path: |
          ${{ env.OPENWRT_PATH }}/feeds
          ${{ env.OPENWRT_PATH }}/dl
          ${{ env.OPENWRT_PATH }}/package/feeds

    - name: 缓存DL软件包
      id: cache_dl
      uses: actions/cache@main
      with:
        key: ${{ env.CACHE_VERSION }}-dl-${{ env.SOURCE_REPO }}-${{ env.REPO_BRANCH }}-${{ env.SOURCE_HASH }}
        restore-keys: |
          ${{ env.CACHE_VERSION }}-dl-${{ env.SOURCE_REPO }}-${{ env.REPO_BRANCH }}-
          ${{ env.CACHE_VERSION }}-dl-${{ env.SOURCE_REPO }}-
        path: |
          ${{ env.OPENWRT_PATH }}/dl

    - name: 检查缓存状态
      run: |
        source "$LOGGER_SCRIPT"
        step_start "CACHE_STATUS" "检查缓存状态"
        
        # 工具链缓存
        if [ "${{ steps.cache_toolchain.outputs.cache-hit }}" == "true" ]; then
            log "INFO" "✅ 工具链缓存命中"
            CACHE_STATUS_TOOLCHAIN="HIT"
        else
            log "INFO" "❌ 工具链缓存未命中，将重新构建"
            CACHE_STATUS_TOOLCHAIN="MISS"
        fi
        
        # Feeds缓存
        if [ "${{ steps.cache_feeds.outputs.cache-hit }}" == "true" ]; then
            log "INFO" "✅ Feeds缓存命中"
            CACHE_STATUS_FEEDS="HIT"
        else
            log "INFO" "❌ Feeds缓存未命中，将重新更新"
            CACHE_STATUS_FEEDS="MISS"
        fi
        
        # DL缓存
        if [ "${{ steps.cache_dl.outputs.cache-hit }}" == "true" ]; then
            log "INFO" "✅ DL软件包缓存命中"
            CACHE_STATUS_DL="HIT"
        else
            log "INFO" "❌ DL软件包缓存未命中，将重新下载"
            CACHE_STATUS_DL="MISS"
        fi
        
        # 显示缓存大小
        for dir in ".ccache" "staging_dir" "feeds" "dl"; do
            if [ -d "$OPENWRT_PATH/$dir" ]; then
                size=$(du -sh "$OPENWRT_PATH/$dir" | cut -f1)
                log "INFO" "$dir 大小: $size"
            fi
        done
        
        # 更新报告
        echo "CACHE_STATUS_TOOLCHAIN=$CACHE_STATUS_TOOLCHAIN" >> $GITHUB_ENV
        echo "CACHE_STATUS_FEEDS=$CACHE_STATUS_FEEDS" >> $GITHUB_ENV
        echo "CACHE_STATUS_DL=$CACHE_STATUS_DL" >> $GITHUB_ENV
        
        step_complete "CACHE_STATUS" "success"

    - name: 刷新缓存
      run: |
        source "$LOGGER_SCRIPT"
        step_start "REFRESH_CACHE" "刷新缓存时间戳"
        
        if [ -d "$OPENWRT_PATH/staging_dir" ]; then
            log "INFO" "刷新staging_dir时间戳..."
            find "$OPENWRT_PATH/staging_dir" -type d -name "stamp" -not -path "*target*" | while read -r dir; do
                find "$dir" -type f -exec touch {} +
            done
            log "INFO" "缓存刷新完成"
        else
            log "WARN" "未找到staging_dir，跳过缓存刷新"
        fi
        
        step_complete "REFRESH_CACHE" "success"

    - name: 添加第三方软件源
      run: |
        source "$LOGGER_SCRIPT"
        step_start "ADD_REPO" "添加第三方软件源"
        
        if [ -f "$REPO_SCRIPT" ]; then
            log "INFO" "执行软件源脚本: $REPO_SCRIPT"
            chmod +x "$REPO_SCRIPT" || {
                log "ERROR" "设置脚本权限失败"
                exit 1
            }
            
            cd "$OPENWRT_PATH"
            if "$REPO_SCRIPT"; then
                log "INFO" "软件源脚本执行成功"
            else
                log "ERROR" "软件源脚本执行失败"
                exit 1
            fi
        else
            log "WARN" "软件源脚本不存在，跳过"
        fi
        
        step_complete "ADD_REPO" "success"

    - name: 安装Feeds
      run: |
        source "$LOGGER_SCRIPT"
        step_start "INSTALL_FEEDS" "安装Feeds"
        
        cd "$OPENWRT_PATH"
        
        # 更新feeds
        if [ "${{ steps.cache_feeds.outputs.cache-hit }}" != "true" ]; then
            log "INFO" "更新feeds..."
            show_progress 0 2 "更新feeds"
            if ./scripts/feeds update -a; then
                show_progress 1 2 "更新feeds"
                log "INFO" "Feeds更新成功"
            else
                log "ERROR" "Feeds更新失败"
                exit 1
            fi
        else
            log "INFO" "使用缓存的feeds，跳过更新"
            show_progress 1 2 "使用缓存"
        fi
        
        # 安装feeds
        if [ ! -d "$OPENWRT_PATH/package/feeds" ] || [ -z "$(ls -A $OPENWRT_PATH/package/feeds)" ]; then
            log "INFO" "安装feeds..."
            show_progress 1 2 "安装feeds"
            if ./scripts/feeds install -a; then
                show_progress 2 2 "安装完成"
                log "INFO" "Feeds安装成功"
            else
                log "ERROR" "Feeds安装失败"
                exit 1
            fi
        else
            log "INFO" "feeds已安装，跳过"
            show_progress 2 2 "已安装"
        fi
        
        echo ""
        step_complete "INSTALL_FEEDS" "success"

    - name: 加载自定义配置
      run: |
        source "$LOGGER_SCRIPT"
        step_start "LOAD_CONFIG" "加载自定义配置"
        
        if [ -f "$DIY_SCRIPT" ]; then
            log "INFO" "执行自定义脚本: $DIY_SCRIPT"
            chmod +x "$DIY_SCRIPT" || {
                log "ERROR" "设置脚本权限失败"
                exit 1
            }
            
            cd "$OPENWRT_PATH"
            if "$DIY_SCRIPT"; then
                log "INFO" "自定义脚本执行成功"
            else
                log "ERROR" "自定义脚本执行失败"
                exit 1
            fi
        else
            log "WARN" "自定义脚本不存在，跳过"
        fi
        
        step_complete "LOAD_CONFIG" "success"

    - name: 合并配置文件并生成报告
      id: merge_config
      run: |
        source "$LOGGER_SCRIPT"
        step_start "MERGE_CONFIG" "合并配置文件"
        
        log "INFO" "合并配置文件..."
        
        # 读取合并前的luci软件包
        LUCI_BEFORE=$(grep "^CONFIG_PACKAGE_luci.*=y" "$CONFIG_BASE" | sort || true)
        
        # 合并配置文件
        cat "$CONFIG_BASE" "$CONFIG_BRANCH" > "$OPENWRT_PATH/.config" || {
            log "ERROR" "合并配置文件失败"
            exit 1
        }
        
        # 读取合并后的luci软件包
        LUCI_AFTER=$(grep "^CONFIG_PACKAGE_luci.*=y" "$OPENWRT_PATH/.config" | sort || true)
        
        # 显示合并后的luci软件包
        log "INFO" "=== 合并后的Luci软件包列表 ==="
        if [ -n "$LUCI_AFTER" ]; then
            echo "$LUCI_AFTER" | sed 's/^CONFIG_PACKAGE_//' | sed 's/=y//' | while read pkg; do
                log "INFO" "  - $pkg"
            done
        else
            log "INFO" "  (无Luci软件包)"
        fi
        
        # 运行defconfig
        log "INFO" "运行defconfig..."
        cd "$OPENWRT_PATH"
        if make defconfig; then
            log "INFO" "defconfig成功"
        else
            log "ERROR" "defconfig失败"
            exit 1
        fi
        
        # 读取defconfig后的luci软件包
        LUCI_DEFCONFIG=$(grep "^CONFIG_PACKAGE_luci.*=y" "$OPENWRT_PATH/.config" | sort || true)
        
        # 显示defconfig后的luci软件包
        log "INFO" "=== Defconfig后的Luci软件包列表 ==="
        if [ -n "$LUCI_DEFCONFIG" ]; then
            echo "$LUCI_DEFCONFIG" | sed 's/^CONFIG_PACKAGE_//' | sed 's/=y//' | while read pkg; do
                log "INFO" "  - $pkg"
            done
        else
            log "INFO" "  (无Luci软件包)"
        fi
        
        # 生成defconfig对比报告并输出到控制台
        log "INFO" "=== Defconfig软件包对比 ==="
        
        # 检查是否有新增的软件包
        NEW_PACKAGES=$(comm -13 <(echo "$LUCI_AFTER") <(echo "$LUCI_DEFCONFIG") | sed 's/^CONFIG_PACKAGE_//' | sed 's/=y//')
        if [ -n "$NEW_PACKAGES" ]; then
            log "INFO" "🔍 发现新增的Luci软件包:"
            echo "$NEW_PACKAGES" | while read pkg; do
                log "INFO" "  ✅ $pkg"
                echo "  ✅ $pkg"
            done
        else
            log "INFO" "ℹ️  无新增的Luci软件包"
            echo "  ℹ️  无新增的Luci软件包"
        fi
        
        # 检查是否有缺失的软件包
        MISSING_PACKAGES=$(comm -23 <(echo "$LUCI_AFTER") <(echo "$LUCI_DEFCONFIG") | sed 's/^CONFIG_PACKAGE_//' | sed 's/=y//')
        if [ -n "$MISSING_PACKAGES" ]; then
            log "WARN" "⚠️  发现缺失的Luci软件包:"
            echo "$MISSING_PACKAGES" | while read pkg; do
                log "WARN" "  ❌ $pkg"
                echo "  ❌ $pkg"
            done
        else
            log "INFO" "ℹ️  无缺失的Luci软件包"
            echo "  ℹ️  无缺失的Luci软件包"
        fi
        
        echo ""
        
        # 生成defconfig对比报告文件
        {
            echo "## Defconfig后的Luci软件包变化"
            echo ""
            echo "### 新增的Luci软件包:"
            if [ -n "$NEW_PACKAGES" ]; then
                echo "$NEW_PACKAGES" | while read pkg; do
                    echo "- ✅ $pkg"
                done
            else
                echo "（无新增软件包）"
            fi
            echo ""
            echo "### 缺失的Luci软件包:"
            if [ -n "$MISSING_PACKAGES" ]; then
                echo "$MISSING_PACKAGES" | while read pkg; do
                    echo "- ❌ $pkg"
                done
            else
                echo "（无缺失软件包）"
            fi
            echo ""
        } > "$GITHUB_WORKSPACE/luci_defconfig_report.md"
        
        # 生成合并差异报告
        {
            echo "## Luci软件包合并报告"
            echo ""
            echo "### 新增的Luci软件包:"
            comm -13 <(echo "$LUCI_BEFORE") <(echo "$LUCI_AFTER") | sed 's/^CONFIG_PACKAGE_//' | sed 's/=y//' | while read pkg; do
                echo "- ✅ $pkg"
            done
            echo ""
            echo "### 缺失的Luci软件包:"
            comm -23 <(echo "$LUCI_BEFORE") <(echo "$LUCI_AFTER") | sed 's/^CONFIG_PACKAGE_//' | sed 's/=y//' | while read pkg; do
                echo "- ❌ $pkg"
            done
            echo ""
        } > "$GITHUB_WORKSPACE/luci_report.md"
        
        step_complete "MERGE_CONFIG" "success"

    - name: 下载DL软件包
      run: |
        source "$LOGGER_SCRIPT"
        step_start "DOWNLOAD_PKGS" "下载软件包"
        
        cd "$OPENWRT_PATH"
        log "INFO" "开始下载软件包..."
        
        # 创建错误监控脚本
        cat > /tmp/monitor_download_errors.sh << 'EOF'
        #!/bin/bash
        LOG_FILE="$1"
        ERROR_PATTERNS=("failed to download" "Error:" "ERROR:" "error:" "404 Not Found" "Connection refused" "timeout")
        
        tail -f "$LOG_FILE" | while read line; do
            for pattern in "${ERROR_PATTERNS[@]}"; do
                if echo "$line" | grep -qi "$pattern"; then
                    # 提取包名
                    PACKAGE=$(echo "$line" | grep -o 'package/[^/]*' | head -1 | cut -d'/' -f2)
                    if [ -z "$PACKAGE" ]; then
                        PACKAGE=$(echo "$line" | grep -o '[a-zA-Z0-9_-]*\.tar\.' | head -1 | sed 's/\.tar\.$//')
                    fi
                    if [ -z "$PACKAGE" ]; then
                        PACKAGE="未知"
                    fi
                    
                    # 调用错误记录函数
                    log_build_error "$line" "$PACKAGE"
                fi
            done
        done
        EOF
        chmod +x /tmp/monitor_download_errors.sh
        
        # 启动错误监控（后台）
        /tmp/monitor_download_errors.sh /tmp/download.log &
        MONITOR_PID=$!
        
        # 监控下载进度
        if make download -j$(nproc) 2>&1 | tee /tmp/download.log; then
            log "INFO" "软件包下载成功"
        else
            kill $MONITOR_PID 2>/dev/null || true
            log "ERROR" "软件包下载失败"
            
            # 分析下载错误
            DOWNLOAD_ERRORS=$(grep -E "(failed|Error|ERROR|404|timeout)" /tmp/download.log | tail -5)
            if [ -n "$DOWNLOAD_ERRORS" ]; then
                log_build_error "下载失败: $DOWNLOAD_ERRORS" "下载错误"
            fi
            exit 1
        fi
        
        kill $MONITOR_PID 2>/dev/null || true
        step_complete "DOWNLOAD_PKGS" "success"

    - name: 清理构建环境
      run: |
        source "$LOGGER_SCRIPT"
        step_start "CLEAN_ENV" "清理构建环境"
        
        cd "$OPENWRT_PATH"
        log "INFO" "清理构建环境..."
        
        if make clean; then
            log "INFO" "构建环境清理成功"
        else
            log "WARN" "构建环境清理失败，继续执行"
        fi
        
        # 确保工具链正确构建
        log "INFO" "准备工具链..."
        if make toolchain/install -j$(nproc); then
            log "INFO" "工具链准备成功"
        else
            log "ERROR" "工具链准备失败"
            exit 1
        fi
        
        step_complete "CLEAN_ENV" "success"

    - name: 编译基础环境
      id: compile
      run: |
        source "$LOGGER_SCRIPT"
        step_start "COMPILE" "编译基础环境"
        
        cd "$OPENWRT_PATH"
        log "INFO" "开始编译基础环境..."
        log "INFO" "使用 $(nproc) 个线程编译"
        
        # 创建增强的错误监控脚本
        cat > /tmp/monitor_errors.sh << 'EOF'
        #!/bin/bash
        LOG_FILE="$1"
        # 扩展错误模式，包含更多错误类型
        ERROR_PATTERNS=(
            "failed to build"
            "failed to install"
            "Error:"
            "ERROR:"
            "error:"
            "make.*\*\*\*.*Error"
            "command terminated with signal"
            "cannot stat"
            "No such file or directory"
            "Permission denied"
            "Segmentation fault"
            "Compilation failed"
            "Build failed"
            "undefined reference"
            "multiple definition"
        )
        
        tail -f "$LOG_FILE" | while read line; do
            for pattern in "${ERROR_PATTERNS[@]}"; do
                if echo "$line" | grep -q "$pattern"; then
                    # 提取包名 - 改进包名提取逻辑
                    PACKAGE=$(echo "$line" | grep -oE 'package/[^/]*|/tmp/[^/]*' | head -1 | cut -d'/' -f2)
                    if [ -z "$PACKAGE" ]; then
                        PACKAGE=$(echo "$line" | grep -oE '[a-zA-Z0-9_-]+\.tar\.[a-z0-9]+' | head -1 | sed 's/\.tar\.[a-z0-9]+$//')
                    fi
                    if [ -z "$PACKAGE" ]; then
                        PACKAGE=$(echo "$line" | grep -oE 'ERROR: package/[^\s]+' | sed 's/ERROR: package\///')
                    fi
                    if [ -z "$PACKAGE" ]; then
                        PACKAGE="未知"
                    fi
                    
                    # 调用错误记录函数
                    log_build_error "$line" "$PACKAGE"
                    break  # 只记录第一个匹配的错误模式
                fi
            done
        done
        EOF
        chmod +x /tmp/monitor_errors.sh
        
        # 定义编译阶段（避免在子shell中使用local）
        stages=("工具链和内核" "系统包" "所有包")
        commands=("toolchain/kernel-headers compile" "package/system/opkg/host/compile" "")
        total=3
        current=0
        
        for i in "${!stages[@]}"; do
            current=$((i + 1))
            show_progress $current $total "编译${stages[$i]}"
            
            if [ -n "${commands[$i]}" ]; then
                log "INFO" "编译${stages[$i]}..."
                
                # 启动错误监控（后台）
                /tmp/monitor_errors.sh /tmp/build.log &
                MONITOR_PID=$!
                
                if make -j$(nproc) ${commands[$i]} 2>&1 | tee /tmp/build.log; then
                    log "INFO" "${stages[$i]}编译成功"
                else
                    kill $MONITOR_PID 2>/dev/null || true
                    log "WARN" "${stages[$i]}并行编译失败，尝试单线程编译"
                    
                    # 单线程编译时也监控错误
                    /tmp/monitor_errors.sh /tmp/build.log &
                    MONITOR_PID=$!
                    
                    if make -j1 V=s ${commands[$i]} 2>&1 | tee /tmp/build.log; then
                        log "INFO" "${stages[$i]}单线程编译成功"
                    else
                        kill $MONITOR_PID 2>/dev/null || true
                        log "ERROR" "${stages[$i]}编译彻底失败"
                        
                        # 分析最后几行日志，提取关键错误
                        LAST_ERRORS=$(tail -20 /tmp/build.log | grep -E "(failed|Error|ERROR|undefined|multiple)" | tail -3)
                        if [ -n "$LAST_ERRORS" ]; then
                            echo "$LAST_ERRORS" | while read error_line; do
                                log_build_error "$error_line" "编译失败"
                            done
                        fi
                        exit 1
                    fi
                fi
                
                kill $MONITOR_PID 2>/dev/null || true
            else
                log "INFO" "编译所有包..."
                
                # 启动错误监控（后台）
                /tmp/monitor_errors.sh /tmp/build.log &
                MONITOR_PID=$!
                
                if make -j$(nproc) 2>&1 | tee /tmp/build.log; then
                    log "INFO" "所有包编译成功"
                else
                    kill $MONITOR_PID 2>/dev/null || true
                    log "WARN" "并行编译失败，尝试单线程编译"
                    
                    # 单线程编译时也监控错误
                    /tmp/monitor_errors.sh /tmp/build.log &
                    MONITOR_PID=$!
                    
                    if make -j1 V=s 2>&1 | tee /tmp/build.log; then
                        log "INFO" "单线程编译成功"
                    else
                        kill $MONITOR_PID 2>/dev/null || true
                        log "ERROR" "编译彻底失败"
                        
                        # 分析最后几行日志，提取关键错误
                        LAST_ERRORS=$(tail -20 /tmp/build.log | grep -E "(failed|Error|ERROR|undefined|multiple)" | tail -3)
                        if [ -n "$LAST_ERRORS" ]; then
                            echo "$LAST_ERRORS" | while read error_line; do
                                log_build_error "$error_line" "编译失败"
                            done
                        fi
                        exit 1
                    fi
                fi
                
                kill $MONITOR_PID 2>/dev/null || true
            fi
        done
        
        echo ""
        echo "status=success" >> $GITHUB_OUTPUT
        echo "DATE=$(date +"%Y-%m-%d %H:%M:%S")" >> $GITHUB_ENV
        echo "FILE_DATE=$(date +"%Y.%m.%d")" >> $GITHUB_ENV
        
        step_complete "COMPILE" "success"

    - name: 生成构建报告
      if: always()
      run: |
        source "$LOGGER_SCRIPT"
        step_start "GEN_REPORT" "生成构建报告"
        
        # 完成报告
        jq --arg time "$(date -Iseconds)" --arg status "${{ steps.compile.outputs.status }}" \
            '.end_time = $time | .status = $status' "$REPORT_FILE" > "$REPORT_FILE.tmp" && \
            mv "$REPORT_FILE.tmp" "$REPORT_FILE"
        
        # 生成摘要报告
        {
            echo "=== 构建摘要 ==="
            echo "构建ID: $BUILD_ID"
            echo "仓库: $REPO_URL"
            echo "分支: $REPO_BRANCH"
            echo "芯片: $CHIP_FAMILY"
            echo "设备: $DEVICE_NAMES"
            echo "状态: ${{ steps.compile.outputs.status }}"
            echo "开始时间: $(jq -r '.start_time' "$REPORT_FILE")"
            echo "结束时间: $(date -Iseconds)"
            echo ""
            echo "=== 缓存状态 ==="
            echo "工具链缓存: $CACHE_STATUS_TOOLCHAIN"
            echo "Feeds缓存: $CACHE_STATUS_FEEDS"
            echo "DL缓存: $CACHE_STATUS_DL"
            echo ""
            echo "=== 错误统计 ==="
            echo "错误数量: $(jq '.errors | length' "$REPORT_FILE")"
            echo "警告数量: $(jq '.warnings | length' "$REPORT_FILE")"
            echo "构建错误数量: $(jq '.build_errors | length' "$REPORT_FILE")"
            echo ""
            if [ "$(jq '.build_errors | length' "$REPORT_FILE")" -gt 0 ]; then
                echo "=== 构建错误详情 ==="
                jq -r '.build_errors[] | "- [\(.time)] \(.package): \(.message)"' "$REPORT_FILE"
                echo ""
            fi
            if [ "$(jq '.errors | length' "$REPORT_FILE")" -gt 0 ]; then
                echo "=== 其他错误详情 ==="
                jq -r '.errors[] | "- [\(.time)] \(.step): \(.message)"' "$REPORT_FILE"
                echo ""
            fi
            if [ "$(jq '.warnings | length' "$REPORT_FILE")" -gt 0 ]; then
                echo "=== 警告详情 ==="
                jq -r '.warnings[] | "- [\(.time)] \(.step): \(.message)"' "$REPORT_FILE"
                echo ""
            fi
        } > "$GITHUB_WORKSPACE/build_summary.txt"
        
        log "INFO" "构建报告已生成"
        cat "$GITHUB_WORKSPACE/build_summary.txt"
        
        step_complete "GEN_REPORT" "success"

    - name: 检查空间使用情况
      if: (!cancelled())
      run: |
        source "$LOGGER_SCRIPT"
        step_start "CHECK_SPACE" "检查磁盘空间"
        
        log "INFO" "=== 磁盘空间使用情况 ==="
        df -hT
        
        log "INFO" "=== 目录大小统计 ==="
        for dir in "bin" "staging_dir" ".ccache" "feeds" "dl"; do
            if [ -d "$OPENWRT_PATH/$dir" ]; then
                size=$(du -sh "$OPENWRT_PATH/$dir" | cut -f1)
                log "INFO" "$dir: $size"
            fi
        done
        
        step_complete "CHECK_SPACE" "success"

    - name: 上传构建日志和报告
      if: always()
      uses: actions/upload-artifact@main
      with:
        name: ${{ env.SOURCE_REPO }}-logs-${{ env.CHIP_FAMILY }}-${{ env.REPO_SHORT }}-${{ env.FILE_DATE }}
        path: |
          ${{ github.workspace }}/build.log
          ${{ github.workspace }}/build_report.json
          ${{ github.workspace }}/build_summary.txt
          ${{ github.workspace }}/luci_report.md
          ${{ github.workspace }}/luci_defconfig_report.md
        retention-days: 30

    - name: 上传Bin目录
      if: steps.compile.outputs.status == 'success' && env.UPLOAD_BIN_DIR == 'true'
      uses: actions/upload-artifact@main
      with:
        name: ${{ env.SOURCE_REPO }}-bin-${{ env.DEVICE_TARGET }}-${{ env.DEVICE_SUBTARGET }}-${{ env.FILE_DATE }}
        path: ${{ env.OPENWRT_PATH }}/bin

    - name: 整理文件
      if: steps.compile.outputs.status == 'success'
      run: |
        source "$LOGGER_SCRIPT"
        step_start "ORG_FILES" "整理构建文件"
        
        cd "$OPENWRT_PATH/bin/targets/*/*"
        
        # 创建构建信息文件
        {
            echo "=== 基础环境构建信息 ==="
            echo "构建ID: $BUILD_ID"
            echo "芯片系列: $CHIP_FAMILY"
            echo "仓库配置: $REPO_CONFIG"
            echo "源码分支: $REPO_BRANCH"
            echo "构建时间: $DATE"
            echo "内核版本: $VERSION_KERNEL"
            echo "设备名称: $DEVICE_NAMES"
            echo "工具链缓存: $CACHE_STATUS_TOOLCHAIN"
            echo "Feeds缓存: $CACHE_STATUS_FEEDS"
            echo "DL缓存: $CACHE_STATUS_DL"
            echo "构建状态: ${{ steps.compile.outputs.status }}"
        } > base_build_info.txt
        
        # 保存配置文件
        cp "$OPENWRT_PATH/.config" "base_${CHIP_FAMILY}_${REPO_SHORT}.config"
        
        log "INFO" "文件整理完成"
        step_complete "ORG_FILES" "success"

    - name: 上传基础环境到Artifact
      if: steps.compile.outputs.status == 'success'
      uses: actions/upload-artifact@main
      with:
        name: ${{ env.SOURCE_REPO }}-base-${{ env.CHIP_FAMILY }}-${{ env.REPO_SHORT }}-${{ env.FILE_DATE }}
        path: |
          ${{ env.OPENWRT_PATH }}/bin
          ${{ env.OPENWRT_PATH }}/.config
          ${{ env.OPENWRT_PATH }}/staging_dir
          ${{ env.OPENWRT_PATH }}/.ccache
          ${{ env.OPENWRT_PATH }}/feeds
          ${{ env.OPENWRT_PATH }}/dl
        retention-days: 30

    - name: 清理过期缓存
      if: (!cancelled())
      run: |
        source "$LOGGER_SCRIPT"
        step_start "CLEAN_CACHE" "清理过期缓存"
        
        log "INFO" "清理超过7天的旧缓存..."
        CUTOFF_DATE=$(date -d '7 days ago' +%Y-%m-%d)
        
        # 清理工具链缓存
        gh cache list --key ${{ env.CACHE_VERSION }}-${{ env.SOURCE_REPO }}-${{ env.REPO_BRANCH }}-${{ env.DEVICE_TARGET }}-${{ env.DEVICE_SUBTARGET }}- --json key,created_at --jq '.[] | select(.created_at < "'$CUTOFF_DATE'") | .key' | while read -r key; do
            log "INFO" "删除过期工具链缓存: $key"
            gh cache delete "$key" || log "WARN" "删除缓存失败: $key"
        done
        
        # 清理feeds缓存
        gh cache list --key ${{ env.CACHE_VERSION }}-feeds-${{ env.SOURCE_REPO }}-${{ env.REPO_BRANCH }}- --json key,created_at --jq '.[] | select(.created_at < "'$CUTOFF_DATE'") | .key' | while read -r key; do
            log "INFO" "删除过期feeds缓存: $key"
            gh cache delete "$key" || log "WARN" "删除缓存失败: $key"
        done
        
        # 清理DL缓存
        gh cache list --key ${{ env.CACHE_VERSION }}-dl-${{ env.SOURCE_REPO }}-${{ env.REPO_BRANCH }}- --json key,created_at --jq '.[] | select(.created_at < "'$CUTOFF_DATE'") | .key' | while read -r key; do
            log "INFO" "删除过期DL缓存: $key"
            gh cache delete "$key" || log "WARN" "删除缓存失败: $key"
        done
        
        step_complete "CLEAN_CACHE" "success"

    - name: 完成构建
      if: always()
      run: |
        source "$LOGGER_SCRIPT"
        
        if [ "${{ steps.compile.outputs.status }}" = "success" ]; then
            log "INFO" "🎉 构建成功完成！"
            echo "::notice::构建成功完成！构建ID: $BUILD_ID"
        else
            log "ERROR" "💥 构建失败！"
            echo "::error::构建失败！请查看日志了解详情。构建ID: $BUILD_ID"
        fi
        
        # 最终报告
        echo "::group::构建摘要"
        cat "$GITHUB_WORKSPACE/build_summary.txt"
        echo "::endgroup::"
